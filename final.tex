\documentclass{article}
\usepackage[german]{babel}
\usepackage[pdftex]{graphicx}
\usepackage{natbib}
\usepackage{url}
\usepackage{listings}
\usepackage{appendix}
\usepackage{subfig}
\usepackage{comment}
\oddsidemargin 0.0in 
\evensidemargin 1.0in
\textwidth 6.0in 
\DeclareMathSizes{12}{20}{14}{10}
\title{Abschlussaufgabe V - Partikelfilter in ARNL}
\author{Nils Petersohn, Matrikel: 20022749}
\date{3. Feb. 2010}
\begin{document}
\maketitle
%\begin{abstract}
%\end{abstract}

\tableofcontents
\listoftables

\section{Aufgabenstellung}
Es soll die monte-carlo-lokalisierung in Arnl untersucht werden. Durch Experimente und Recherche soll der genaue Ablauf des Partikelfilters und die Wirkung der Parameter dargestellt werden. Ausserdem soll geklaert werden wie die lokalisierung in eigenen programmen genutzt werden kann.


\section{Einf\"uhrung}\label{einfuehrung}



\subsection{ARIA}
Die C++ Bibliothek ARIA ist eine API fuer alle MobileRobots/ActivMedia Plattformen. Mit der Hilfe von ARIA kann u.a. Geschwindigkeit, Richtung oder relative Richtung entweder durch einfache oder komplexe Anweisungen kontrolliert werden.
%ARIA folgt dem Client-Server Paradigma. Der Roboter oder der Simulator sind Server. 
%\includegraphics{img/aria-arch.jpg}



\subsection{ArNetworking}

ArNetworking ist eine API in ARIA um eine client-server Architektur zwischen dem Robotter(Server) und dem entfernten Rechner(Client) ueber das Netzwerk aufzubauen. Der Client berechnet Bewegungsbefehle und sendet Anfragen an den Server welche dann vom Robotter ausgefuehrt werden. Der Robotter hingegen sendet u.a. seine Odometriedaten. 


\subsection{MobileEyes}
MobileEyes kann sich mit ARIA, ArNetworking und ARNL Server verbinden und dessen Umgebung also interne Karte anzeigen.
Unter anderem kann man mit MobileEyes Bewegungskomandos an den Robotter schicken.\cite{whitbrook1}








\section{Theoretischer Hintergrund}
Das Lokalisierungsmodul von ARNL benutzt die Monte-Carlo-Lokalisierung. Diese basiert auf der Markov-Annahme welche wiederum auf die Bayes-Regel fundiert.




\subsection{Probabilistische Lokalisierung}
Um die Position eines Roboters zu berechnen, gibt es verschiedene Ansätze. Sie beruhen alle auf der Fusionierung von Daten, die durch die Odometrie und weitere Sensoren des Roboters geliefert werden. Gebräuchliche Sensoren für autonome Roboter sind Ultraschallsensoren oder Laserscanner.
Diese Ansätze verwenden Methoden der Wahrscheinlichkeitsrechnung zur Bestimmung eine Wahrscheinlichkeitsverteilung über alle möglichen Positionen, an denen der Roboter sich befinden kann.

in ARIA umgesetzt in ARNL

leistungsfähiger, verbreiteter Ansatz
vereint relative und absolute Postionierung als
 Bewegungsmodellierung und Wahrnehmung der Umwelt

\subsection{Beyes Filter}
\subsection{Markov-Lokalisierung}
Das Ziel der Markov Lokalisierung ist es, jeder möglichen Roboterposition einen
Wahrscheinlichkeitswert zuzuordnen.
\subsection{Partikelfilter}
Bei der Lösung mittels Partikel-Filern wird die Pose des Roboters über eine Partikelwolke repräsentiert. Jeder Partikel stellt eine mögliche Pose des Roboters dar. Über den Partikelfilter wird jeder Partikel, also jede dadurch repräsentierte Pose, auf ihre Plausibilität überprüft. Die Wahrscheinlichkeit plausibler Partikel wird heraufgesetzt, die Wahrscheinlichkeit wenig plausibler Partikel wird reduziert. Fallen Partikel unter einen bestimmten Wahrscheinlichkeits-Schwellwert, werden sie verworfen.

\subsection{Monte-Carlo-Lokalisierung}
Der Vorteil des MCL - Ansatzes ist, dass zur Laufzeit die Gr\"osse der
Stichprobenmenge variabel sein kann. Je unsicherer die Roboterposition ist,
desto größer fällt die Stichprobenmenge aus. In Analogie zur
„Gitterbasierenden“ (grid-based) Methode, m\"usste bei einer hohen Sicherheit
(belief) nur ein Teil des Zustandsraumes aktualisiert werden.\cite{delipetkos1}
Der Grundgedanke bei der Monte Carlo Lokalisierung ist, das „Belief“
(Vertrauen) mittels einer Stichprobenmenge, welche auch als „samples“ oder
auch „particles“ bezeichnet wird, darzustellen. MCL ist ein iterativer Bayes´scher
Filter, welcher als ein Schätzer f\"ur die zuk\"unftige Wahrscheinlichkeitsverteilung
der Roboterposition verwendet wird.
Monte-Carlo-Lokalisierung
\begin{itemize}
\item MCL erlaubt elegante Fusion der Daten verschiedener Sensorik
\item MCL skalierbar (Partikelanzahl)
\item MCL effizient, bspw. dynamische Anpassung der Partikelanzahl (adaptiv)

\item Particle filters are an implementation of recursive Bayesian filtering
\item They represent the posterior by a set of weighted samples.
\item In the context of localization, the particles are propagated according to the motion model.
\item They are then weighted according to the likelihood of the observations.
\item In a re-sampling step, new particles are drawn with a probability proportional to the likelihood of the observation.
Monte Carlo Localization = Markov-Lokalisierung mit Abbildung der
\item Wahrscheinlichkeit als Samplemenge (Partikelwolke)
\item Sample = eine Position (x,y,θ)
\item Prognose-Schritt: jedes Sample erzeugt ein neues Sample entsprechend
unscharfem Bewegungsmodell -> neue Samplemenge bel‘
\item Korekktur-Schritt:
\item  Jedes Partikel aus bel‘ erhält ein Gewicht nach dem Sensormodell (wie eine
Fitness, Übereinstimmung mit Wahrnehmung)
\item  neue Samplemenge bel wird durch zufällige Selektion anhand der Fitness aus
bel‘ erzeugt
\item  ständige Evolution einer Partikelwolke anhand von Bewegungsbefehlen und
Sensorwahrnehmung,
\end{itemize}
\section{Experimente}

In einem Beispielprogramm wird ARNL und ArNetworking verwendet um einen Server zu erstellen. Clients wie MobileEyes koennen sich mit diesem Server verbinden. MobileEyes sendet anfragen an den Server um den Robotter zu steuern, die aktuelle Karte abzufragen, Lokalisierungsparameter zu setzen, Sensordaten abzufragen und den Robotter manuell wieder neu zu lokalisieren.
Die automatische lokalisierung des Robotters erfolgt durch eine Instanz von ArLocalizationTask welcher also Teil des Serverprograms ist. Wie in \ref{einfuehrung} deutlich gemacht wurde, ist das Monte-Carlo Verfahren in der Klasse ArLocalizationTask implementiert.
Durch die Verwendung von MobileEyes kann eine Anpassung der Lokalisierungsparameter Einfluss auf den Partikelfilter genommen werden.
Die Einstellungen befinden sich in MobileEyes unter Lokalisierungseinstellungen. Eine  liste und deren Beschreibung befinden sich in Appendix I.
Der Monte Carlo Filter verlaesst sich unter anderem auf die Odometriedaten die von den Raedern kommen. Dabei kann bestimmt werden wie weit der Robotter gefahren ist oder wenn sich die Raeder unterschiedlich bewegen, wie weit sich der Robotter um seine Achse gedreht hat. wenn man die genaue Startposition des Robotters kennt und auch die Odometriedaten der Raeder, so kann man theoretisch die genaue Position des Robotters zum Zeitpunk t bestimmen. In der Praxis ist dies aber nur schwer zu realisieren. Die Unsicherheit
wächst also mit zunehmender Entfernung vom Startpunkt. generell gibt es drei Odometrie Fehlerarten:
\begin{itemize}
\item Entfernungsfehler: Fehler beim Zur\"ucklegen einer geraden Strecke
\item Drehfehler: Fehler beim Drehen des Roboters
\item Driftfehler: Orientierungsfehler beim Zur\"ucklegen einer geraden Strecke
\end{itemize}

Das Bewegungsmodell in ARIA/ARNL bildet genau diese Fehler ab.
Um die Bewegungsunschaerfe zu testen muessen verschiedene Initialalparameter verwendet werden:
\begin{itemize}
\item PassThreshold muss auf 0 gesetzt werden um zu vermeiden, dass der Roboter in den Lost Modus geht
\item Um die Partikelwolke besser sichtbar zu machen wird der Wert NumSamples auf 5000 gesetzt
\item PeturbX, PeturbY, PeturbTh sind Paramter um neue Samples samples nach dem resampling prozess hizuzuf\"ugen. Diese Streuwerte werden auf null gesetzt um den Rechenanspruch zu verrringern.
\item per default wird die Neuberechnung der Position erst nach einer Bewegung von 20 cm gemacht. Eine Neuberechnung soll erst nach 2m stattfinden. Somit wird der Paramter Triggerdistance auf 2000 gesetzt 
\item die neuberechnung nach einer drehnung soll nicht erst ab 5 Grad erfolgen sondern schon ab 0 Grad. Der Paramter \textbf{TriggerAngle} wird also auf 0 gesetzt.
\end{itemize}

Um den Entfernungsfehlerverhaeltnissparameter zu testen wird der Drehfehlerparameter und der Driftfehler zuerst ausgeschaltet. Um den Parameter zu untersuchen wird er auf 0.5 gesetzt. Dies soll bewirken, dass die Partikelwolke sich um die H\"alfte der zurueckgelegten Strecke ausdehnt. Der Roboter wird zuerst an einem Punkt lokalisiert. Mit einem Bewegungsbefehl wird der Robotter nun 1 Meter gerade aus bewegt. Wie angenommen hat die Partikelwolke nun eine L\"ange von 50 cm. 

\begin{figure}[KMmPerMmTest]
  \centering
  \fbox{
    \includegraphics[scale=0.55]{img/KMmPerMmTest.jpg}
  }
  \caption{KMmPerMm = 0.5}
  \label{KMmPerMmTest}
\end{figure}


Dieser Parameter kann dazu verwendet werden um die Lokalisation in bezug auf die Oberflaechenbeschaffenheit anzupassen. In einem h\"ugligem Gel\"ande kann der Roboter eine Steigung hochfahren sich aber im eigentlichen Sinne nicht so schnell weiterbewegen wie die Odometriedaten es uebermitteln. Desshalb muss dieser Parameter erh\"oht werden.

Mit dem Drehfehlerparameter kann nach der Dokumentation in Anhang \ref{KDegPerDegDoc} die Unsicherheit der Drehung beeinflusst werden. Wenn der Robotter sich z.B. auf einem leicht unebenen Untergrund dreht ist die Drehung nicht eindeutig an den Odometriedaten nachvollziehbar. 
Um diesen zu testen wird der Parameter zuerst auf 1 gesetzt und Entfernungsfehlerverhaeltnissparameter wieder auf null.
In Abbildung \ref{KDegPerDegTest100} wurde der Roboter um 360 Grad gedreht und dann 1cm gerade aus gefahren. Der Parameter wurde in Abbildung \ref{KDegPerDegTest050} und \ref{KDegPerDegTest025} stufenweise halbiert um den Winkel der Partikelstreuung zu erkennen. Dieser Entspricht demnach dem Verhaeltnis zwischen der Drehung in Grad und der KDegPerDeg Einstellung. Also bei einer Drehnung von 360 Grad und einer einstellung von 1 hat der Partikelfilter eine breite von auch ca. 360 Grad bei 0.5 von ca. 180 Grad und bei 0.25 von ca. 90 Grad. Wenn also der Untergrund h\"uglig ist, sollte die Unsicherheit also der KDegPerDeg Paramter hoeher eingestellt sein. 


\begin{figure}
  \centering
  \subfloat[KDegPerDeg = 1]{\label{KDegPerDegTest100}\includegraphics[width=0.31\textwidth]{img/KDegPerDegTest100.jpg}}                
  \ \subfloat[KDegPerDeg = 0.5]{\label{KDegPerDegTest050}\includegraphics[width=0.3\textwidth]{img/KDegPerDegTest050.jpg}}
  \ \subfloat[KDegPerDeg = 0.25]{\label{KDegPerDegTest025}\includegraphics[width=0.29\textwidth]{img/KDegPerDegTest025.jpg}}
  \caption{KDegPerDeg Parameter Test}
  \label{KDegPerDegTestFigure}
\end{figure}

\newpage
Der Parameter KMmPerMm betrifft die unsicherheit der Odometriedaten der Raeder. Bei einem differenziellem Antrieb koennen leichte unterschiede auftreten, wenn der Robotter sich gerade aus bewegt. Wenn der Robotter sich z.B. auf einem unebenen Boden fortbewegt, kann er nach links und rechts abdriften. Die Odometriedaten der Raeder geben aber ein stetiges geradeausfahren zurueck.

\begin{figure}
  \centering
  \subfloat[KDegPerMm = 0.02]{\label{KDegPerMm002}\includegraphics[width=0.3\textwidth]{img/KDegPerMm002.jpg}}                
  \ \subfloat[KDegPerMm = 0.01]{\label{KDegPerMm001}\includegraphics[width=0.45\textwidth]{img/KDegPerMm001.jpg}}
  \ \subfloat[KDegPerMm = 0.005]{\label{KDegPerMm0005}\includegraphics[width=0.55\textwidth]{img/KDegPerMm0005.jpg}}
  \caption{KDegPerMm Parameter Test}
  \label{KDegPerMmTestFigure}
\end{figure}

Durch eine einfache Winkelfunktionsrechnung in Abbildung \ref{Winkelfunktionen} laesst sich der Winkel bestimmen. 
Zuerst wird der mittelwert der Abweichung durch das Arithmetische Mittel bestimmt siehe Formel \ref{getY}


\begin{figure}
  \centering
  \includegraphics[width=0.5\textwidth]{img/Winkelfunktionen_einheitskreis.jpg}               
  \caption{Winkelfunktionen im Einheitskreis }\url{http://www.ullala.at/experiments/movement/images/circ_1.gif}
  \label{Winkelfunktionen}
\end{figure}

\begin{figure}
	\begin{equation}\label{getY}	
		\bar{y}=\frac{790+660}{2}=725mm
	\end{equation}
	\begin{equation}\label{getX}	
		\theta_1=\sin^{-1} \left( \frac{y}{r} \right) \cdot 2
	\end{equation}
	\begin{equation}\label{theta1}	
		\theta_1=\sin^{-1}\left(\frac{725}{1000} \right) \cdot 2 \approx 93^\circ
	\end{equation}	
  \caption{Berechnung fuer Abbildung \ref{KDegPerMm002}}
  \label{KDegPerMm002Calc}
\end{figure}

\begin{figure}
	\begin{equation}\label{get001Y}	
		\bar{y}=\frac{430+320}{2}=375mm
	\end{equation}
	\begin{equation}\label{get001X}	
		\theta_2=\sin^{-1} \left( \frac{y}{r} \right) \cdot 2
	\end{equation}
	\begin{equation}\label{theta2}	
		\theta_2=\sin^{-1} \left( \frac{375}{1000} \right) \cdot 2 \approx 44^\circ
	\end{equation}	
  \caption{Berechnung fuer Abbildung \ref{KDegPerMm001}}
  \label{KDegPerMm001Calc}
\end{figure}

\begin{figure}
	\begin{equation}\label{get0005Y}	
		\bar{y}=\frac{190+200}{2}=195mm
	\end{equation}
	\begin{equation}\label{get0005X}	
		\theta_3=\sin^{-1} \left( \frac{y}{r} \right) \cdot 2
	\end{equation}
	\begin{equation}\label{theta3}	
		\theta_3=\sin^{-1} \left( \frac{195}{1000} \right) \cdot 2 \approx 23^\circ
	\end{equation}
  \caption{Berechnung fuer Abbildung \ref{KDegPerMm0005}}
  \label{KDegPerMm0005Calc}
\end{figure}

Um die Rechnungen zu bestaetigen Rechnen wir den Wert aus welcher zu einem Fehlerwinkel von $180^\circ$ noetig ist und bilden dann davon das Arithmetische Mittel. Wenn dieses nicht sonderlich abweicht waren die Rechnungen richtig. Dies ist der Fall denn eine maximale Abweichung von weniger als 0.012 und eine Minimale Abweichung von 0.0009 ist anehmbar. 

\begin{figure}
	\begin{equation}\label{get0005Y}	
		\frac{\theta}{KDegPerMm}=\frac{180^\circ}{x}
	\end{equation}
	\begin{equation}\label{get0005Y}	
		{x_0}=\frac{180^\circ \cdot 0.005}{23}=0.0391
	\end{equation}
	\begin{equation}\label{get0005Y}	
		{x_1}=\frac{180^\circ \cdot 0.01}{44}=0.0409
	\end{equation}
	\begin{equation}\label{get0005Y}	
		{x_2}=\frac{180^\circ \cdot 0.02}{93}=0.0387
	\end{equation}
	\begin{equation}\label{get0005Y}
		\bar{x}=\frac{x_0+x_1+x_2}{3} \approx 0.04
	\end{equation}
  \caption{Test der Berechnungen in Abbildung \ref{theta1},\ref{theta2},\ref{theta3}}
  \label{KDegPerMm0005Calc}
\end{figure}

Die Bestaetigung liefert eine Einstellung von KDegPerMm = 0.04 welche eine $180^\circ$ ausgedehnte Partikelwolke aufspannt siehe Abbildung \ref{KDegPerMm004Test}.

\begin{figure}
	\centering
	\includegraphics[width=0.3\textwidth]{img/KDegPerMm004.jpg}
	\caption{KDegPerMm = 0.04}
	  \label{KDegPerMm004Test}
\end{figure}

Somit laesst sich der Parameter nachvollziehen. Wenn man einen Winkel $\alpha$ erreichen will muss man Rechnen: $KDegPerMm = \alpha \cdot 2.22 \cdot 10^{-4}$
Diese Rechnung ist nicht genau und wurde mit Rundungswerten ermittelt. 

\section{Nutzung der Lokalisierung in eigenen Programmen}

ARNL(Advanced Robotics Navigation and Localization System) ist eine Teilbibliothek in ARIA um Navigations und Lokalisationsschnittstellen zur Verf\"ugung zu stellen. Die Lokalisationskomponente bietet eine Schnittstelle um den angeschlossenen Roboter zu lokalisieren. Sensor und Odometriedaten des Roboters werden in Verbindung mit einer vorhanden Umgebungskarte verwendet um die wahrscheinlichste Position des Roboters in der Karte zu bestimmen. \cite{arnl} 
Die ARNL Bibliothek beinhaltet Lokalisierung mit Sonar (SonArnl), Laserscanner (Arnl) und GPS (Mogs). Die Klasse ArLocalizationTask kann Daten vom Laserscanner (ArSick) auswerten um die Lokalisierung durchzufuehren. Abgesehen vom ArLocalizationTask gibt es noch andere Klassen fuer die Lokalisierung. Die Elternklasse ist ArBaseLocalizationTask in der BaseARNL Bibliothek. \cite{arnl}
Um den ArLocalizationTask zu instanzieren m\"ussen Pointer von Instanzen der Typen ArRobot, ArRangeDevice und ArMapInterface (ArMap) uerbgeben werden. Eine Karte kann durch senorDaten erzeugt werden aber auch durch das Program Mapper3. Die Instanz von ArLocalizationTask startet einen eigenen asynchronen Hintergrund-thread um anhand des Lasersensors wiederholend den Roboter zu lokalisieren. Die Position wird anhand der Berechnungen im ArLocalizationTask neu gesetzt.


\lstset{language=C++}
\begin{lstlisting}
#include "ArLocalizationTask.h"
...
ArRobot robot;
...
ArLaser *firstLaser = robot.findLaser(1);
...
ArMap map(fileDir);
...
ArLocalizationTask locTask(&robot, firstLaser, &map);
\end{lstlisting}
Um eine initiale Lokalierung durchzufuehren muss die Methode localizeRobotAtHomeBlocking ohne Parameter aufgerufen werden.
Eine Instanz von ArLocalizationManager erlaubt Ausgabedaten von verschiedenen Lokalisationsthreads zu vereinigen. Durch die Methode addLocalizationTask kann eine neue Instanz von ArBaseLocalizationTask wie z.B. ArSonarLocalizationTask oder ArLocalizationTask hinzugefuegt werden. Durch die Methode fuseTwoDistributions kann man die Daten fusionieren.
\lstset{language=C++}
\begin{lstlisting}
ArLocalizationManager locManager(&robot, &arMap);
ArLocalizationTask locTask (&robot, &sick, &arMap);
locManager.addLocalizationTask(&locTask);
\end{lstlisting}

Die KonfigurationsDatei arnl.p ist fuer eine erfolgreiche Lokalisation notwendig. Darin befinden sich u.a. Einstellungen fuer die Monte-Carlo-Lokalisation.
Diese Konfigurationsdatei wird durch einen Parser ausgelesen:

\lstset{language=C++}
\begin{lstlisting}
ArArgumentParser parser(&argc, argv);
parser.loadDefaultArguments();
...
// Create service that allows client to change configuration parameters in ArConfig 
ArServerHandlerConfig handlerConfig (
	&server, Aria::getConfig (),
	Arnl::getTypicalDefaultParamFileName (),
	Aria::getDirectory ()
);

// Read in parameter files.
Aria::getConfig()->useArgumentParser(&parser);
Aria::getConfig()->parseFile (Arnl::getTypicalParamFileName() )
\end{lstlisting}

\newpage



\section{Zusammenfassung und Ausblick}


%3 parameter ausreichend getestet und die anderen uebersetzt
%mitternacht oder mittag
%eigenes programm = mobile eyes ersetzen?
% mailinglisten


%LLS = Laser Localization Score =
%das aktuelle maximale Gewicht, d.h.
%wie gut stimmt das beste Sample
%mit der Sensorwahrnehmung
%überein, Maximum 1.0
\newpage


\appendix
\section{Appendix I}

\paragraph{Map}          Karte der Umgebung um zu Navigieren. 

\paragraph{NumSamples} 2000           minumum 0,  No of pose samples for MCL. The larger
                          this number, the more computation will localization
                          take. Too low a number will cause the robot to lose
                          localization. This is also the maximum no of samples
                          which will be used for localization if no of samples
                          are varied along with the localization score.

\paragraph{GridRes} 100               minimum 10,  The resolution of the occupancy grid
                          representing the map in mm. Smaller resolution
                          results in more accuracy but more computation.

\paragraph{PassThreshold} 0.2         range [0, 1],  After MCL sensor correction, the
                          sample with the maximum probablity will have a score
                          based on the match between sensor and the map
                          points. This is the minimum score out of 1.0 to be
                          considered localized.

\paragraph{KMmPerMm} 0.05             minimum 0,  When the robot moves linearly, the error
                          in distance is proportional to the distance moved.
                          This error is is given as a fraction in mm per mm

\paragraph{KDegPerDeg}\label{KDegPerDegDoc} 0.05           minimum 0,  When the robot rotates, the error in the
                          angle is proportional to the angle turned. This is
                          expressed as a fraction in degs per deg.

\paragraph{KDegPerMm} 0.0025          minimum 0,  When the robot moves linearly it can
                          also affect its orientation. This drift can be
                          expressed as a fraction in degs per mm.

\paragraph{TriggerDistance} 200       minimum 0,  Since MCL localization is
                          computationally expensive, it is triggered only when
                          the robot has moved this far in mm.

\paragraph{TriggerAngle} 5            minimum 0,  Since MCL localization is
                          computationally expensive, it is triggered only when
                          the robot has rotated this far in degs.

\paragraph{TriggerTimeEnabled} false  This flag will decide if the localization will be
                          called every 'TriggerTime' msecs. Once this flag is
                          true the IdleTimeTrigger* parameters will take
                          effect. This feature is meant to take care of cases
                          when the robot has not moved much for a time and the
                          position should be refined .

\paragraph{TriggerTime} 10000         minimum 1500,  Once the TriggerTimeFlag is set to
                          true this parameter will decide how long the robot
                          has been idle in milli seconds before it starts a
                          localization near the last known robot pose.

\paragraph{IdleTimeTriggerX} 200      minimum 0,  When localization is triggered by idle
                          time this parameter decides the range of the samples
                          in X coords in mm.

\paragraph{IdleTimeTriggerY} 200      minimum 0,  When localization is triggered by idle
                          time this parameter decides the range of the samples
                          in Y coords in mm.

\paragraph{IdleTimeTriggerTh} 15      minimum 0,  When localization is triggered by idle
                          time this parameter decides the range of the samples
                          in Theta coords in degs.

\paragraph{RecoverOnFail} false       If localization fails, this flag will decide if a
                          static localization is attempted around last known
                          robot pose. Such a reinitialization can cause the
                          robot to be hopelessly lost if the actual robot is
                          very different from its known pose

\paragraph{FailedX} 300               minimum 0,  Range of the box in the X axis in mm to
                          distribute samples after localization fails.

\paragraph{FailedY} 300               minimum 0,  Range of the box in the Y axis in mm to
                          distribute samples after localization fails.

\paragraph{FailedTh} 45               minimum 0,  Range of the angle in degs to distribute
                          samples after localization fails.

\paragraph{PeturbX}\label{PeturbX} 10                minimum 0,  After sensor correction and resampling
                          the chosen pose is perturbed to generate a new
                          sample. This parameter decides the range to peturb
                          the X axis in mm.

\paragraph{PeturbY}\label{PeturbY} 10                minimum 0,  After sensor correction and resampling
                          the chosen pose is perturbed to generate a new
                          sample. This parameter decides the range to peturb
                          the Y axis in mm.

\paragraph{PeturbTh}\label{PeturbTh} 1                minimum 0,  After sensor correction and resampling
                          the chosen pose is perturbed to generate a new
                          sample. This parameter decides the range to peturb
                          the angle in degs.

\paragraph{PeakStdX} 10               minimum 0,  Extent of the ellipse in the X axis in
                          mm beyond which the sample poses will be considered
                          multiple localizations after resampling.

\paragraph{PeakStdY} 10               minimum 0,  Extent of the ellipse in the X axis in
                          mm beyond which the sample poses will be considered
                          multiple localizations after resampling.

\paragraph{PeakStdTh} 1               minimum 0,  Extent of the angle in degs beyond which
                          the sample poses will be considered multiple
                          localizations after resampling.

\paragraph{PeakFactor} 1e-06          range [0, 1],  When a no of samples have non zero
                          probabilities such as when there is ambiguities in a
                          corridor. This is the threshold below the maximum
                          probablity to be considered a valid hypothesis.

\paragraph{StdX} 400                  minimum 0,  The standard deviation of the gaussian
                          ellipse in X axis in mm at start of localization.

\paragraph{StdY} 400                  minimum 0,  The standard deviation of the gaussian
                          ellipse in Y axis in mm at start of localization.

\paragraph{StdTh} 30                  minimum 0,  The standard deviation of the gaussian
                          angle in degs at start of localization.

\paragraph{SensorBelief} 0.9          range [0, 1],  Probablility that a range reading
                          from the laser is valid. This is used in the
                          correction of the probablities of the samples using
                          the sensor.

\paragraph{OccThreshold} 0.1          range [0, 1],  The threshold value of the occupancy
                          grid to consider as occupied.

\paragraph{AngleIncrement} 0          range [0, 180],  Only the laser readings which are
                          this many degrees apart are used for the
                          localization. The lower limit is decided by the
                          LaserIncrement setting

\paragraph{DiscardThreshold} 0.33     range [0.33, 1],  A robot sample pose lying inside
                          an occupancy grid cell with a value above this will
                          be usually discarded Useful in cases where robot may
                          intersect map points such as during patrolbot
                          docking
\paragraph{Kalman Filter}
Weitere Parameter betreffen den Kalman Filter welcher nicht Bestandteil dieser Arbeit ist. 

\bibliographystyle{abbrv}
\bibliography{main}
\begin{thebibliography}{------}
	\bibitem[Wiki-ARNL]{arnl} MobileRobots Inc, \emph{ARNL, SONARNL and MOGS},  wiki (9 September 2009), available at 
		\url{http://robots.mobilerobots.com/wiki/ARNL,_SONARNL_and_MOGS}.
	
	
	
	\bibitem[Delipetkos1]{delipetkos1} Fraunhofer Gesellschaft AIS.ARC, Particle Filter
			Ein probabilistischer Ansatz zur Lokalisierung mobiler Roboter available at S. 12
			\url{http://www.ais.fraunhofer.de/~delipetk}
	
	
	
	
	\bibitem[ARNL-Ref]{arnl-ref} MobileRobots Inc, \emph{ARNL-Reference}, (1.7.0) available at 				
	\url{http://vigir.missouri.edu/~gdesouza/Research/MobileRobotics/Software/ARNL-SONARNL/Arnl-1.7.0+gcc41/docs/ARNL-Reference/index.html}.
	
	
	\bibitem[Borens 1996]{Borens1996} Borenstein, J., Everett, H.R., Feng, L., April 1996, Where am I? Sensors and Methods for Mobile Robot Positioning. Technical Report, The University of Michigan. Seite 131 Chapter 5: Dead-Reckoning
	
	
	\bibitem[Whitbrook1]{whitbrook1}
		Dr. Amanda Whitbrook.
		{\em Programming Mobile Robots with Aria and Player}.
		Springer-Verlag London Limited , 2010, S. 50
		\url{http://www.ais.fraunhofer.de/~delipetk}

\end{thebibliography}
\listoffigures
\end{document}